// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Vite
// plugin that tells the Electron app where to look for the Vite-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_VITE_DEV_SERVER_URL: string;
declare const MAIN_WINDOW_VITE_NAME: string;

// Preload types
interface ThemeModeContext {
  toggle: () => Promise<boolean>;
  dark: () => Promise<void>;
  light: () => Promise<void>;
  system: () => Promise<boolean>;
  current: () => Promise<"dark" | "light" | "system">;
}
interface ElectronWindow {
  minimize: () => Promise<void>;
  maximize: () => Promise<void>;
  close: () => Promise<void>;
  getSize: () => Promise<{ width: number; height: number }>;
}

interface ElectronBackend {
  getBackendUrl: () => Promise<string | null>;
  healthCheck: () => Promise<boolean>;
  restartBackend: () => Promise<{ port: number; url: string }>;
}

declare interface Window {
  themeMode: ThemeModeContext;
  electronWindow: ElectronWindow;
  electronBackend: ElectronBackend;
  grpc: GrpcAPI;
  electronGrpc: GrpcAPI;
}

// Minimal preload API surface so TS recognizes window.grpc usages.
// Many shapes are simplified on purpose; precise typing can be added later.
interface GrpcAPI {
  healthCheck: () => Promise<{ healthy: boolean; version?: string }>;
  helloWorld: (request: { message: string }) => Promise<{ message: string }>;
  echoParameter: (request: { value: number; operation: string }) => Promise<{ originalValue: number; processedValue: number; operation: string }>;
  getFeatures: (request: { bounds: any; featureTypes: string[]; limit: number }) => Promise<{ features: any[]; total_count?: number }>;

  // Streaming helpers
  getBatchDataStreamed?: (
    request: { bounds: any; dataTypes: string[]; maxPoints: number; resolution?: number },
    onData?: (data: any) => void
  ) => Promise<any[]>;

  getBatchDataWorkerStreamed: (
    bounds: any,
    dataTypes: string[],
    maxPoints: number,
    resolution?: number,
    onProgress?: (progress: { processed: number; total: number; percentage: number; phase: string }) => void,
    onChunkData?: (chunk: any) => void
  ) => Promise<{ totalProcessed: number; processingTime: number; generationMethod: string; summary: Record<string, unknown>; dataSample?: any[] }>;

  getBatchDataChildProcessStreamed: (
    bounds: any,
    dataTypes: string[],
    maxPoints: number,
    resolution?: number,
    onProgress?: (progress: { processed: number; total: number; percentage: number; phase: string }) => void
  ) => Promise<{ stats?: any; chartConfig?: any; message?: string }>;

  getBatchDataOptimized: (
    bounds: any,
    dataTypes: string[],
    maxPoints: number,
    resolution?: number,
    onProgress?: (progress: { processed: number; total: number; percentage: number; phase: string }) => void,
    onChunkData?: (chunk: any) => void,
    options?: { threshold?: number }
  ) => Promise<any>;

  fetchChartDataInChunks: (requestId: string) => Promise<Array<[number, number, number]>>;
  stopStream: () => Promise<any>;
}
