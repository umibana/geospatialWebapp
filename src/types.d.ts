// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Vite
// plugin that tells the Electron app where to look for the Vite-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_VITE_DEV_SERVER_URL: string;
declare const MAIN_WINDOW_VITE_NAME: string;

// Preload types
interface ThemeModeContext {
  toggle: () => Promise<boolean>;
  dark: () => Promise<void>;
  light: () => Promise<void>;
  system: () => Promise<boolean>;
  current: () => Promise<"dark" | "light" | "system">;
}
interface ElectronWindow {
  minimize: () => Promise<void>;
  maximize: () => Promise<void>;
  close: () => Promise<void>;
  getSize: () => Promise<{ width: number; height: number }>;
}

interface ElectronBackend {
  getBackendUrl: () => Promise<string | null>;
  healthCheck: () => Promise<boolean>;
  restartBackend: () => Promise<{ port: number; url: string }>;
}

interface ElectronAPI {
  showOpenDialog: (options: Electron.OpenDialogOptions) => Promise<Electron.OpenDialogReturnValue>;
  showSaveDialog: (options: Electron.SaveDialogOptions) => Promise<Electron.SaveDialogReturnValue>;
  readCsvPreview: (filePath: string, numRows?: number) => Promise<{ headers: string[]; rows: string[][]; delimiter: string }>;
  // IPC communication methods for worker thread processing
  send: (channel: string, data: any) => void;
  on: (channel: string, listener: (event: any, data: any) => void) => void;
  off: (channel: string, listener: (event: any, data: any) => void) => void;
}

declare interface Window {
  themeMode: ThemeModeContext;
  electronWindow: ElectronWindow;
  electronBackend: ElectronBackend;
  electronAPI: ElectronAPI;
  grpc: GrpcAPI;
  electronGrpc: GrpcAPI;
  autoGrpc: import('./grpc-auto/auto-context').AutoGrpcContext;
}

// Minimal preload API surface so TS recognizes window.grpc usages.
// Many shapes are simplified on purpose; precise typing can be added later.
interface GrpcAPI {
  healthCheck: () => Promise<{ healthy: boolean; version?: string }>;
  helloWorld: (request: { message: string }) => Promise<{ message: string }>;
  echoParameter: (request: { value: number; operation: string }) => Promise<{ originalValue: number; processedValue: number; operation: string }>;
  getFeatures: (request: { bounds: { northeast: { latitude: number; longitude: number }; southwest: { latitude: number; longitude: number } }; featureTypes: string[]; limit: number }) => Promise<{ features: Array<{ id: string; name: string; location: { latitude: number; longitude: number; altitude?: number }; properties: Record<string, string>; timestamp: number }>; total_count?: number }>;

  // CSV file processing methods
  analyzeCsv: (request: { filePath: string; fileName: string; rowsToAnalyze?: number }) => Promise<{
    columns: Array<{ name: string; type: string; is_required: boolean }>;
    auto_detected_mapping: Record<string, string>;
    success: boolean;
    error_message?: string;
  }>;
  sendFile: (request: { 
    filePath: string; 
    fileName: string; 
    fileType: string; 
    xVariable: string; 
    yVariable: string; 
    zVariable?: string; 
    idVariable?: string; 
    depthVariable?: string,
    columnTypes?: Record<string, 'string' | 'number'>,
    includeFirstRow?: boolean,
    includedColumns?: string[]
  }) => Promise<{
    total_rows_processed: number;
    valid_rows: number;
    invalid_rows: number;
    errors: string[];
    success: boolean;
    processing_time: string;
  }>;
  getLoadedDataStats: () => Promise<{
    total_points: number;
    x_stats: Record<string, number>;
    y_stats: Record<string, number>;
    z_stats: Record<string, number>;
    available_columns: string[];
    has_data: boolean;
  }>;
  getLoadedDataChunk: (offset: number, limit: number) => Promise<{
    rows: Array<{ x: number; y: number; z: number; id: string; metrics: Record<string, number>; attrs: Record<string, string> }>;
    total_rows: number;
    is_complete: boolean;
    next_offset: number;
    available_metric_keys: string[];
  }>;

  // Streaming helpers
  getBatchDataStreamed?: (
    request: { bounds: { northeast: { latitude: number; longitude: number }; southwest: { latitude: number; longitude: number } }; dataTypes: string[]; maxPoints: number; resolution?: number },
    onData?: (data: unknown) => void
  ) => Promise<unknown[]>;

  // getBatchDataWorkerStreamed removed - use getBatchDataOptimized instead

  getBatchDataChildProcessStreamed: (
    bounds: { northeast: { latitude: number; longitude: number }; southwest: { latitude: number; longitude: number } },
    dataTypes: string[],
    maxPoints: number,
    resolution?: number,
    onProgress?: (progress: { processed: number; total: number; percentage: number; phase: string }) => void
  ) => Promise<{ stats?: Record<string, unknown>; chartConfig?: Record<string, unknown>; message?: string }>;

  getBatchDataOptimized: (
    bounds: { northeast: { latitude: number; longitude: number }; southwest: { latitude: number; longitude: number } },
    dataTypes: string[],
    maxPoints: number,
    resolution?: number,
    onProgress?: (progress: { processed: number; total: number; percentage: number; phase: string }) => void,
    onChunkData?: (chunk: unknown) => void,
    options?: { threshold?: number }
  ) => Promise<Record<string, unknown>>;

  fetchChartDataInChunks: (requestId: string) => Promise<Array<[number, number, number]>>;
  stopStream: (requestId?: string) => Promise<{ success: boolean; cancelled?: boolean }>;
  aggregateCsvSeries: (xAxis: 'x'|'y'|'z', yAxis: 'x'|'y'|'z', metrics: string[], sampleCap?: number) => Promise<{ success: boolean; series?: Record<string, Array<[number, number, number, string | undefined]>>; ranges?: Record<string, { min: number; max: number }>; total?: number; error?: string }>;
}
