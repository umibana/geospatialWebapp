// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Vite
// plugin that tells the Electron app where to look for the Vite-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_VITE_DEV_SERVER_URL: string;
declare const MAIN_WINDOW_VITE_NAME: string;

// Preload types
interface ThemeModeContext {
  toggle: () => Promise<boolean>;
  dark: () => Promise<void>;
  light: () => Promise<void>;
  system: () => Promise<boolean>;
  current: () => Promise<"dark" | "light" | "system">;
}
interface ElectronWindow {
  minimize: () => Promise<void>;
  maximize: () => Promise<void>;
  close: () => Promise<void>;
  getSize: () => Promise<{ width: number; height: number }>;
}

interface ElectronBackend {
  getBackendUrl: () => Promise<string | null>;
  healthCheck: () => Promise<boolean>;
  restartBackend: () => Promise<{ port: number; url: string }>;
}

interface ElectronAPI {
  showOpenDialog: (options: Electron.OpenDialogOptions) => Promise<Electron.OpenDialogReturnValue>;
  showSaveDialog: (options: Electron.SaveDialogOptions) => Promise<Electron.SaveDialogReturnValue>;
  readCsvPreview: (filePath: string, numRows?: number) => Promise<{ headers: string[]; rows: string[][]; delimiter: string }>;
}

declare interface Window {
  themeMode: ThemeModeContext;
  electronWindow: ElectronWindow;
  electronBackend: ElectronBackend;
  electronAPI: ElectronAPI;
  grpc: GrpcAPI;
  electronGrpc: GrpcAPI;
}

// Minimal preload API surface so TS recognizes window.grpc usages.
// Many shapes are simplified on purpose; precise typing can be added later.
interface GrpcAPI {
  healthCheck: () => Promise<{ healthy: boolean; version?: string }>;
  helloWorld: (request: { message: string }) => Promise<{ message: string }>;
  echoParameter: (request: { value: number; operation: string }) => Promise<{ originalValue: number; processedValue: number; operation: string }>;
  getFeatures: (request: { bounds: any; featureTypes: string[]; limit: number }) => Promise<{ features: any[]; total_count?: number }>;

  // CSV file processing methods
  analyzeCsv: (request: { filePath: string; fileName: string; rowsToAnalyze?: number }) => Promise<{
    columns: Array<{ name: string; type: string; is_required: boolean }>;
    auto_detected_mapping: Record<string, string>;
    success: boolean;
    error_message?: string;
  }>;
  sendFile: (request: { 
    filePath: string; 
    fileName: string; 
    fileType: string; 
    xVariable: string; 
    yVariable: string; 
    zVariable?: string; 
    idVariable?: string; 
    depthVariable?: string,
    columnTypes?: Record<string, 'string' | 'number'>,
    includeFirstRow?: boolean,
    includedColumns?: string[]
  }) => Promise<{
    total_rows_processed: number;
    valid_rows: number;
    invalid_rows: number;
    errors: string[];
    success: boolean;
    processing_time: string;
  }>;
  getLoadedDataStats: () => Promise<{
    total_points: number;
    x_stats: Record<string, number>;
    y_stats: Record<string, number>;
    z_stats: Record<string, number>;
    available_columns: string[];
    has_data: boolean;
  }>;

  // Streaming helpers
  getBatchDataStreamed?: (
    request: { bounds: any; dataTypes: string[]; maxPoints: number; resolution?: number },
    onData?: (data: any) => void
  ) => Promise<any[]>;

  getBatchDataWorkerStreamed: (
    bounds: any,
    dataTypes: string[],
    maxPoints: number,
    resolution?: number,
    onProgress?: (progress: { processed: number; total: number; percentage: number; phase: string }) => void,
    onChunkData?: (chunk: any) => void
  ) => Promise<{ totalProcessed: number; processingTime: number; generationMethod: string; summary: Record<string, unknown>; dataSample?: any[] }>;

  getBatchDataChildProcessStreamed: (
    bounds: any,
    dataTypes: string[],
    maxPoints: number,
    resolution?: number,
    onProgress?: (progress: { processed: number; total: number; percentage: number; phase: string }) => void
  ) => Promise<{ stats?: any; chartConfig?: any; message?: string }>;

  getBatchDataOptimized: (
    bounds: any,
    dataTypes: string[],
    maxPoints: number,
    resolution?: number,
    onProgress?: (progress: { processed: number; total: number; percentage: number; phase: string }) => void,
    onChunkData?: (chunk: any) => void,
    options?: { threshold?: number }
  ) => Promise<any>;

  fetchChartDataInChunks: (requestId: string) => Promise<Array<[number, number, number]>>;
  stopStream: (requestId?: string) => Promise<{ success: boolean; cancelled?: boolean }>;
}
